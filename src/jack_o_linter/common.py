"""Reusable code for multiple APIs"""
# Standard imports
from abc import ABC, abstractmethod
from pathlib import Path
from typing import List, Optional

# Third-party imports
from pygount import SourceAnalysis


class APIWrapper(ABC):
    """Abstract base class to wrap APIs of common static/dynamic analysis tools.
    This class will be extended by other APIs to create a common entrypoint for
    each of the supported tools/libraries.

    Attributes:
        score (Optional[float]): Score out of 100.
        errors (Optional[List[str]]): List of errors.
        self.warnings (Optional[List[str]]): List of warnings.
    """
    def __init__(self):
        # Results
        self.score: Optional[float] = None
        self.errors: Optional[List[str]] = None
        self.warnings: Optional[List[str]] = None

    @abstractmethod
    def run(self, target: Path, *args, **kwargs):
        """Run the API tool.

        Updates the class attributes for score, errors, and warnings.

        Args:
            target (Path): The file or directory to run the tool against.
        """

    def get_errors(self) -> List[str]:
        """Get the errors generated by the analysis tool.

        Returns:
            List[str]: List of errors
        """
        self._validate_results()

        return self.errors

    def get_warnings(self) -> List[str]:
        """Get the warnings generated by the analysis tool.

        Returns:
            List[str]: List of warnings
        """
        self._validate_results()
        return self.warnings

    def get_score(self) -> float:
        """Get the score out of 100 generated by the analysis tool.

        Returns:
            float: Score out of 100. 100 is perfect.
        """
        self._validate_results()
        return self.get_score

    @staticmethod
    def source_lines_of_code(src: Path) -> int:
        """Count source lines of code for a directory/file. Ignores non-Python
        files.

        Args:
            src (Path): Directory or file of Python code

        Returns:
            int: Number of Python code lines.
        """
        # Make sure the target is a pathlib Path
        target_path = Path(src)
        total_code_lines = 0

        if target_path.is_dir():
            files = target_path.rglob('*.py')
        else:
            files = [target_path] if target_path.suffix == '.py' else []

        for file_path in files:
            analysis = SourceAnalysis.from_file(str(file_path), 'python', encoding='utf-8')
            total_code_lines += analysis.code

        return total_code_lines

    def _convert_args_to_list(self, target: Path, *args, **kwargs) -> List[str]:
        """Convert function *args and **kwargs into a list of CLI arguments.

        Examples:
            ```
            _convert_args_to_list("some/path", "pos1", 1, 2, some_arg="foo") ->
                ["pos1", "1", "2", "--some-arg=foo", "some/path"]
            ```

            ```
            _convert_args_to_list("file.py", some_bool=True, some_arg="str") ->
                ["--some-bool", "--some-arg=str", "file.py"]
            ```

        Args:
            target (Path): The file or directory to run the API against.

        Returns:
            List[str]: List of combined positional and keyword CLI args.
        """
        # Get a list of all the positional args
        arg_list = list(map(str, args))

        # Convert keyword args to `--some-key=value` format
        for key, value in kwargs.items():
            # Format the CLI option
            option = f"--{key.replace('_', '-')}"

            # Add bools as flags w/o values
            if isinstance(value, bool):
                if value:
                    arg_list.append(option)

            # Add flags with values in `--some-key=value` format
            else:
                arg_list.append(f"{option}={value}")

        # Add the target path/file/dir as the last positional arg
        arg_list.append(str(target))

        return arg_list

    def _validate_results(self) -> None:
        """Validate the analysis tool ran before fetching results.

        Raises:
            RuntimeError: Must execute self.run() before fetching results.
        """
        if self.score is None:
            raise RuntimeError(f"Must execute {self.__class__.__name__}.run(*args, **kwargs) "
                               "before fetching the results.")

    def _calculate_score(self, src: Path) -> None:
        """Calculate API score.

        Some analysis tools do not generate a "score" like PyLint.
        Generate a score based on the number of errors, warnings, and the number
        of source lines of code. 100 is a perfect score. 0 is the minimum.

        Args:
            src (Path): The file or directory to type check with mypy.
        """
        self.score = max(
            0,
            # Get a score relative to the source lines of code.
            # Subtract 100/lines_of_code for each error and
            # Subtract 50/lines_of_code for each warnings and
            100 - (
                ((len(self.errors) / self.source_lines_of_code(src)) * 100) +
                ((len(self.warnings) / self.source_lines_of_code(src)) * 50)
            )
        )